/* @preserve
    _____ __ _     __                _
   / ___// /(_)___/ /___  ____      (_)___
  / (_ // // // _  // -_)/ __/_    / /(_-<
  \___//_//_/ \_,_/ \__//_/  (_)__/ //___/
                              |___/

  Version: 1.7.2
  Author: Nick Piscitelli (pickykneee)
  Website: https://nickpiscitelli.com
  Documentation: http://nickpiscitelli.github.io/Glider.js
  License: MIT License
  Release Date: October 25th, 2018

*/
!(function(e) {
    typeof define === 'function' && define.amd
        ? define(e)
        : typeof exports === 'object'
        ? (module.exports = e())
        : e();
})(function() {
    const a = typeof window !== 'undefined' ? window : this;
    const e = (a.Glider = function(e, t) {
        const o = this;
        if (e._glider) return e._glider;
        if (
            ((o.ele = e),
            o.ele.classList.add('glider'),
            ((o.ele._glider = o).opt = {
                slidesToScroll: 1,
                slidesToShow: 1,
                resizeLock: !0,
                duration: 0.5,
                easing(e, t, o, i, r) {
                    return i * (t /= r) * t + o;
                },
                ...t,
            }),
            (o.animate_id = o.page = o.slide = 0),
            (o.arrows = {}),
            (o._opt = o.opt),
            o.opt.skipTrack)
        )
            o.track = o.ele.children[0];
        else
            for (
                o.track = document.createElement('div'),
                    o.ele.appendChild(o.track);
                o.ele.children.length !== 1;

            )
                o.track.appendChild(o.ele.children[0]);
        o.track.classList.add('glider-track'),
            o.init(),
            (o.resize = o.init.bind(o, !0)),
            o.event(o.ele, 'add', { scroll: o.updateControls.bind(o) }),
            o.event(a, 'add', { resize: o.resize });
    });
    const t = e.prototype;
    return (
        (t.init = function(e, t) {
            const o = this;
            let i = 0;
            let r = 0;
            (o.slides = o.track.children),
                [].forEach.call(o.slides, function(e) {
                    e.classList.add('glider-slide');
                }),
                (o.containerWidth = o.ele.clientWidth);
            const s = o.settingsBreakpoint();
            if (
                ((t = t || s),
                o.opt.slidesToShow === 'auto' || o.opt._autoSlide)
            ) {
                const l = o.containerWidth / o.opt.itemWidth;
                o.opt._autoSlide = o.opt.slidesToShow = o.opt.exactWidth
                    ? l
                    : Math.floor(l);
            }
            o.opt.slidesToScroll === 'auto' &&
                (o.opt.slidesToScroll = Math.floor(o.opt.slidesToShow)),
                (o.itemWidth = o.opt.exactWidth
                    ? o.opt.itemWidth
                    : o.containerWidth / o.opt.slidesToShow),
                [].forEach.call(o.slides, function(e) {
                    (e.style.height = 'auto'),
                        (e.style.width = `${o.itemWidth}px`),
                        (i += o.itemWidth),
                        (r = Math.max(e.offsetHeight, r));
                }),
                (o.track.style.width = `${i}px`),
                (o.trackWidth = i),
                o.opt.resizeLock && o.scrollTo(o.slide * o.itemWidth, 0),
                (s || t) && (o.bindArrows(), o.buildDots(), o.bindDrag()),
                o.updateControls(),
                o.emit(e ? 'refresh' : 'loaded');
        }),
        (t.bindDrag = function() {
            const t = this;
            t.mouse = t.mouse || t.handleMouse.bind(t);
            function e() {
                (t.mouseDown = void 0), t.ele.classList.remove('drag');
            }
            const o = {
                mouseup: e,
                mouseleave: e,
                mousedown(e) {
                    (t.mouseDown = e.clientX), t.ele.classList.add('drag');
                },
                mousemove: t.mouse,
            };
            t.ele.classList.toggle('draggable', !0 === t.opt.draggable),
                t.event(t.ele, 'remove', o),
                t.opt.draggable && t.event(t.ele, 'add', o);
        }),
        (t.buildDots = function() {
            const e = this;
            if (e.opt.dots) {
                if (
                    (typeof e.opt.dots === 'string'
                        ? (e.dots = document.querySelector(e.opt.dots))
                        : (e.dots = e.opt.dots),
                    e.dots)
                ) {
                    (e.dots.innerHTML = ''),
                        e.dots.classList.add('glider-dots');
                    for (
                        let t = 0;
                        t < Math.ceil(e.slides.length / e.opt.slidesToShow);
                        ++t
                    ) {
                        const o = document.createElement('button');
                        (o.dataset.index = t),
                            o.setAttribute('aria-label', `Page ${t + 1}`),
                            (o.className = `glider-dot ${t ? '' : 'active'}`),
                            e.event(o, 'add', {
                                click: e.scrollItem.bind(e, t, !0),
                            }),
                            e.dots.appendChild(o);
                    }
                }
            } else e.dots && (e.dots.innerHTML = '');
        }),
        (t.bindArrows = function() {
            const o = this;
            o.opt.arrows
                ? ['prev', 'next'].forEach(function(e) {
                      let t = o.opt.arrows[e];
                      t &&
                          (typeof t === 'string' &&
                              (t = document.querySelector(t)),
                          (t._func = t._func || o.scrollItem.bind(o, e)),
                          o.event(t, 'remove', { click: t._func }),
                          o.event(t, 'add', { click: t._func }),
                          (o.arrows[e] = t));
                  })
                : Object.keys(o.arrows).forEach(function(e) {
                      const t = o.arrows[e];
                      o.event(t, 'remove', { click: t._func });
                  });
        }),
        (t.updateControls = function(e) {
            const d = this;
            e && !d.opt.scrollPropagate && e.stopPropagation();
            const t = d.containerWidth >= d.trackWidth;
            d.opt.rewind ||
                (d.arrows.prev &&
                    d.arrows.prev.classList.toggle(
                        'disabled',
                        d.ele.scrollLeft <= 0 || t
                    ),
                d.arrows.next &&
                    d.arrows.next.classList.toggle(
                        'disabled',
                        Math.ceil(d.ele.scrollLeft + d.containerWidth) >=
                            Math.floor(d.trackWidth) || t
                    )),
                (d.slide = Math.round(d.ele.scrollLeft / d.itemWidth)),
                (d.page = Math.round(d.ele.scrollLeft / d.containerWidth));
            const c = d.slide + Math.floor(Math.floor(d.opt.slidesToShow) / 2);
            let h = Math.floor(d.opt.slidesToShow) % 2 ? 0 : c + 1;
            Math.floor(d.opt.slidesToShow) === 1 && (h = 0),
                d.ele.scrollLeft + d.containerWidth >=
                    Math.floor(d.trackWidth) &&
                    (d.page = d.dots ? d.dots.children.length - 1 : 0),
                [].forEach.call(d.slides, function(e, t) {
                    const o = e.classList;
                    const i = o.contains('visible');
                    const r = d.ele.scrollLeft;
                    const s = d.ele.scrollLeft + d.containerWidth;
                    const l = d.itemWidth * t;
                    const n = l + d.itemWidth;
                    [].forEach.call(o, function(e) {
                        /^left|right/.test(e) && o.remove(e);
                    }),
                        o.toggle('active', d.slide === t),
                        c === t || (h && h === t)
                            ? o.add('center')
                            : (o.remove('center'),
                              o.add(
                                  [
                                      t < c ? 'left' : 'right',
                                      Math.abs(t - (t < c ? c : h || c)),
                                  ].join('-')
                              ));
                    const a = Math.ceil(l) >= r && Math.floor(n) <= s;
                    o.toggle('visible', a),
                        a !== i &&
                            d.emit(`slide-${a ? 'visible' : 'hidden'}`, {
                                slide: t,
                            });
                }),
                d.dots &&
                    [].forEach.call(d.dots.children, function(e, t) {
                        e.classList.toggle('active', d.page === t);
                    }),
                e &&
                    d.opt.scrollLock &&
                    (clearTimeout(d.scrollLock),
                    (d.scrollLock = setTimeout(function() {
                        clearTimeout(d.scrollLock),
                            Math.abs(d.ele.scrollLeft / d.itemWidth - d.slide) >
                                0.02 &&
                                (d.mouseDown ||
                                    d.scrollItem(
                                        d.round(d.ele.scrollLeft / d.itemWidth)
                                    ));
                    }, d.opt.scrollLockDelay || 250)));
        }),
        (t.scrollItem = function(e, t, o) {
            o && o.preventDefault();
            const i = this;
            const r = e;
            if ((++i.animate_id, !0 === t))
                (e *= i.containerWidth),
                    (e = Math.round(e / i.itemWidth) * i.itemWidth);
            else {
                if (typeof e === 'string') {
                    const s = e === 'prev';
                    if (
                        ((e =
                            i.opt.slidesToScroll % 1 || i.opt.slidesToShow % 1
                                ? i.round(i.ele.scrollLeft / i.itemWidth)
                                : i.slide),
                        s
                            ? (e -= i.opt.slidesToScroll)
                            : (e += i.opt.slidesToScroll),
                        i.opt.rewind)
                    ) {
                        const l = i.ele.scrollLeft;
                        e =
                            s && !l
                                ? i.slides.length
                                : !s &&
                                  l + i.containerWidth >=
                                      Math.floor(i.trackWidth)
                                ? 0
                                : e;
                    }
                }
                (e = Math.max(Math.min(e, i.slides.length), 0)),
                    (i.slide = e),
                    (e = i.itemWidth * e);
            }
            return (
                i.scrollTo(
                    e,
                    i.opt.duration * Math.abs(i.ele.scrollLeft - e),
                    function() {
                        i.updateControls(),
                            i.emit('animated', {
                                value: r,
                                type:
                                    typeof r === 'string'
                                        ? 'arrow'
                                        : t
                                        ? 'dot'
                                        : 'slide',
                            });
                    }
                ),
                !1
            );
        }),
        (t.settingsBreakpoint = function() {
            const e = this;
            const t = e._opt.responsive;
            if (t) {
                t.sort(function(e, t) {
                    return t.breakpoint - e.breakpoint;
                });
                for (let o = 0; o < t.length; ++o) {
                    const i = t[o];
                    if (a.innerWidth >= i.breakpoint)
                        return (
                            e.breakpoint !== i.breakpoint &&
                            ((e.opt = { ...e._opt, ...i.settings }),
                            (e.breakpoint = i.breakpoint),
                            !0)
                        );
                }
            }
            const r = e.breakpoint !== 0;
            return (e.opt = { ...e._opt }), (e.breakpoint = 0), r;
        }),
        (t.scrollTo = function(t, o, i) {
            const r = this;
            const s = new Date().getTime();
            const l = r.animate_id;
            var n = function() {
                const e = new Date().getTime() - s;
                (r.ele.scrollLeft =
                    r.ele.scrollLeft +
                    (t - r.ele.scrollLeft) * r.opt.easing(0, e, 0, 1, o)),
                    e < o && l === r.animate_id
                        ? a.requestAnimationFrame(n)
                        : ((r.ele.scrollLeft = t), i && i.call(r));
            };
            a.requestAnimationFrame(n);
        }),
        (t.removeItem = function(e) {
            const t = this;
            t.slides.length &&
                (t.track.removeChild(t.slides[e]),
                t.refresh(!0),
                t.emit('remove'));
        }),
        (t.addItem = function(e) {
            this.track.appendChild(e), this.refresh(!0), this.emit('add');
        }),
        (t.handleMouse = function(e) {
            const t = this;
            t.mouseDown &&
                ((t.ele.scrollLeft +=
                    (t.mouseDown - e.clientX) * (t.opt.dragVelocity || 3.3)),
                (t.mouseDown = e.clientX));
        }),
        (t.round = function(e) {
            const t = 1 / (this.opt.slidesToScroll % 1 || 1);
            return Math.round(e * t) / t;
        }),
        (t.refresh = function(e) {
            this.init(!0, e);
        }),
        (t.setOption = function(t, e) {
            const o = this;
            o.breakpoint && !e
                ? o._opt.responsive.forEach(function(e) {
                      e.breakpoint === o.breakpoint &&
                          (e.settings = { ...e.settings, ...t });
                  })
                : (o._opt = { ...o._opt, ...t }),
                (o.breakpoint = 0),
                o.settingsBreakpoint();
        }),
        (t.destroy = function() {
            function e(t) {
                t.removeAttribute('style'),
                    [].forEach.call(t.classList, function(e) {
                        /^glider/.test(e) && t.classList.remove(e);
                    });
            }
            const t = this;
            const o = t.ele.cloneNode(!0);
            (o.children[0].outerHTML = o.children[0].innerHTML),
                e(o),
                [].forEach.call(o.getElementsByTagName('*'), e),
                t.ele.parentNode.replaceChild(o, t.ele),
                t.event(a, 'remove', { resize: t.resize }),
                t.emit('destroy');
        }),
        (t.emit = function(e, t) {
            const o = new a.CustomEvent(`glider-${e}`, {
                bubbles: !this.opt.eventPropagate,
                detail: t,
            });
            this.ele.dispatchEvent(o);
        }),
        (t.event = function(e, t, o) {
            const i = e[`${t}EventListener`].bind(e);
            Object.keys(o).forEach(function(e) {
                i(e, o[e]);
            });
        }),
        e
    );
});
